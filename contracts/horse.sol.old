pragma solidity ^0.8.0;
/*
Deposit USDC into pool
depositTo (USDC -> pool)
receive pool tokens
spend pool tokens to place bets - send pool tokens to horse contract

Feature:
    - Keep track of horse index bet that was used by an address last race and
      keep that index (let it ride) by default (they can call placeBet to place their bet on a different horse)
    - Make users deposit AND place bet

[My contract -> Pool together contract] - this will ensure a bet is place when they deposit USDC and then my contract
will forward the request to the group of pooltogether contracts

I was using multiple winners but i dont want to do that anymore
the "SingleRandomWinner.sol" should pick a winner and then call my horse contract to mint and award the NFT
*/

import "../../node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol";
contract MyHorse is ERC721 {
    /*
    enum attitudes = {
        Aggressive,
        Passive,
        Snarky,
        Sneaky,
        Wily,
        Shifty,
        Shrewd,
        Sly,
        Astute,
        Cunning,
        Deceitful,
        Greasy,
        Sharp,
        Slick,
        Tricky,
        Playful,
        Nonchalant,
        Cool,
        Frank,
        Honest,
        Social,
        Aloof,
        Fearful
    }
    enum coatColors {
        YellowDun,
        RedDun,
        MouseGrey,
        Grey,
        DappleGrey,
        FleaBitten,
        RoseGrey,
        Bay,
        Chestnut,
        BloodBay,
        DarkBay,
        BlackBay,
        LiverChestnut,
        Sabino,
        Tobiano,
        SplashWhite,
        FrameOvero,
        Palomino,
        Cremello,
        BuckskinDun,
        Perlino,
        ClassicChampagne,
        GoldChampagne,
        AmberChampagne,
        WhiteChampagne,
        BayRoan,
        RedRoan,
        BlueRoan,
    }
    */

    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    event Award(address addr, uint newItemId, uint horseAttr);

    constructor() ERC721("Horse", "HORSE") {}

    function awardWinner(address winner, string memory tokenURI, uint horseAttr) public allowed returns(uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);
        
        emit Award(winner, newItemId, horseAttr);
        return newItemId;
    }

    modifier allowed() {
        require(msg.sender == owner, "Only the owner of the contract can award a winner");
        _;
    }
}

import "../PeriodicPrizeStrategy.sol";

/* solium-disable security/no-block-members */
contract SingleRandomWinner is PeriodicPrizeStrategy {

  event NoWinner();

  function _distribute(uint256 randomNumber) internal override {
    uint256 prize = prizePool.captureAwardBalance();
    address winner = foo.draw(randomNumber);
    if (winner != address(0)) {
      _awardTickets(winner, prize);
      _awardAllExternalTokens(winner);
    } else {
      emit NoWinner();
    }
  }
}

import "sortition-sum-tree-factory/contracts/SortitionSumTreeFactory.sol";
import "@pooltogether/uniform-random-number/contracts/UniformRandomNumber.sol";
contract MyContract {

    uint balance;
    mapping(bytes32 => address => uint) bets;
    constructor() {}

    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;

    // Ticket-weighted odds
    SortitionSumTreeFactory.SortitionSumTrees internal sortitionSumTrees;

    bytes32 seed = 0;
    uint256 constant private MAX_TREE_LEAVES = 5;

    function getSeedNum() private {
        // change later to accept "last race block or something predictable"
        if (seed == 0) {
            seed = block.blockhash(block.number - 1);
        }
    }

    function genTrees() {
        for (uint i=0; i < NUM_HORSES; i++) {
            sortitionSumTrees.createTree(getHorse(uint16(i), MAX_TREE_LEAVES));
        }
    }

    // @notice Returns the horses chance of winning.
    function chanceOf(uint16 horseIdx) external view returns (uint256) {
        // 10 horses, places 1 ticket on horse A and 10 tickets on horse B
        // idx is the index of the horse
        uint total = 0;
        uint totalForIdx = 0;
        for (uint16 i=0; i < NUM_HORSES; i++) {
            totalForIdx = sortitionSumTrees.total(getHorse(uint16(i)));
            total += totalForIdx;
            if (i == horseIdx) {
                uint horseTotal = totalForIdx;
            }
        }

        return horseTotal / total;
    }

    // XXX: how much the sender would get if their horse wins not sure if this is a percent or what...
    function payoffAmount(uint16 horseIdx) isValidHorse(horseIdx) returns(uint) {
        return sortitionSumTrees.stakeOf(getHorse(uint16(horseIdx), bytes32(uint256(msg.sender))));
    }

    // @notice Selects a user using a random number.  The random number will be uniformly bounded to the ticket totalSupply.
    // @param randomNumber The random number to use to select a user.
    // @return The winner
    function draw(uint256 randomNumber, uint16 winningHorseIdx) isValidHorse(winningHorseIdx) external view override returns (address) {
        uint256 bound = sortitionSumTrees.total(getHorse(uint16(winningHorseIdx)));
        address selected;
        if (bound == 0) {
            selected = address(0);
        } else {
            uint256 token = UniformRandomNumber.uniform(randomNumber, bound);
            selected = address(uint256(sortitionSumTrees.draw(getHorse(uint16(winningHorseIdx), token))));
        }
        return selected;
    }

    function placeBet(uint16 idx) isValidHorse(idx) {
        // idx has to be less then NUM_HORSES
        bets[getHorse(idx)][msg.sender] = msg.value;
        balance += msg.value;
        sortitionSumTrees.set(getHorse(uint16(horseIdx), msg.value, bytes32(uint256(msg.sender))));
    }

    function getHorse(uint16 idx) isValidHorse(idx) public returns(bytes32 horse) {
        return keccak256(abi.encodePacked(seed, idx));
    }

    // mint once we have the attributes/data
    function mintToken(address tokenHolder, bytes memory _data) {
        ERC721._safeMint(tokenHolder, _data);
    }

    function randomNumber() private returns(bytes32 blockHash) {
        return block.blockhash(block.number - 1);
    }

    modifier isValidHorse(uint16 idx) {
        require(idx < NUM_HORSES, "Horse index out of range");
        _;
    }

    /*
    This function will live on the front end, not in the contract

    function determineAttributes(bytes32 randomNum) private returns(uint, uint){
        Horses will have the following traits
           Lets say attitudes are the first 5 bits (2^5 = 0-31)
           Lets say coat colors are the next 5 bits (2^5 = 0-31)
            https://www.equishop.com/en/blog/horse-coat-colours-n136
            Coat Patterns:
                - Blanket/rug
                - Leopard
        
        uint attitude = attitudes[randomNum & bytes32(0x1f)];
        uint coatColor = coatColors[randomNum & bytes32(0x3e0)];
        return attitude, coatColor;
    }
    */
}

// SPDX-License-Identifier: GPL-3.0

//pragma solidity >=0.6.0 <0.7.0;

import "sortition-sum-tree-factory/contracts/SortitionSumTreeFactory.sol";
import "@pooltogether/uniform-random-number/contracts/UniformRandomNumber.sol";

import "./ControlledToken.sol";
import "./TicketInterface.sol";

contract Ticket is ControlledToken, TicketInterface {


    // @notice Initializes the Controlled Token with Token Details and the Controller
    // @param _name The name of the Token
    // @param _symbol The symbol for the Token
    // @param _decimals The number of decimals for the Token
    // @param _controller Address of the Controller contract for minting & burning
    function initialize(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        TokenControllerInterface _controller
    )
    public
    virtual
    override
    initializer
    {
        super.initialize(_name, _symbol, _decimals, _controller);
        genTrees();
    }


    function _beforeTokenTransfer(address from, address to, uint256 amount, uint16 horseIdx) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        // optimize: ignore transfers to self
        if (from == to) {
            return;
        }

        if (from != address(0)) {
            uint256 fromBalance = balanceOf(from).sub(amount);
            sortitionSumTrees.set(getHorse(uint16(horseIdx), fromBalance, bytes32(uint256(from))));
        }

        if (to != address(0)) {
            uint256 toBalance = balanceOf(to).add(amount);
            sortitionSumTrees.set(getHorse(uint16(horseIdx), toBalance, bytes32(uint256(to))));
        }
    }
}
